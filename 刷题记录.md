# 滑动窗口

## [30. 串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)

给定一个字符串 `s` 和一个字符串数组 `words`**。** `words` 中所有字符串 **长度相同**。

 `s` 中的 **串联子串** 是指一个包含 `words` 中所有字符串以任意顺序排列连接起来的子串。

- 例如，如果 `words = ["ab","cd","ef"]`， 那么 `"abcdef"`， `"abefcd"`，`"cdabef"`， `"cdefab"`，`"efabcd"`， 和 `"efcdab"` 都是串联子串。 `"acdbef"` 不是串联子串，因为他不是任何 `words` 排列的连接。

返回所有串联子串在 `s` 中的开始索引。你可以以 **任意顺序** 返回答案。

 

**示例 1：**

```
输入：s = "barfoothefoobarman", words = ["foo","bar"]
输出：[0,9]
解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。
子串 "barfoo" 开始位置是 0。它是 words 中以 ["bar","foo"] 顺序排列的连接。
子串 "foobar" 开始位置是 9。它是 words 中以 ["foo","bar"] 顺序排列的连接。
输出顺序无关紧要。返回 [9,0] 也是可以的。
```

**示例 2：**

```
输入：s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]
输出：[]
解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。
s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。
所以我们返回一个空数组。
```

**示例 3：**

```
输入：s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]
输出：[6,9,12]
解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。
子串 "foobarthe" 开始位置是 6。它是 words 中以 ["foo","bar","the"] 顺序排列的连接。
子串 "barthefoo" 开始位置是 9。它是 words 中以 ["bar","the","foo"] 顺序排列的连接。
子串 "thefoobar" 开始位置是 12。它是 words 中以 ["the","foo","bar"] 顺序排列的连接。
```

思路：因为单词长度相同，那么只要确定一个窗口长度，那么就可以划分若干个唯一的单词，统计窗口内的单词个数，就可以判断了。需要注意的是窗口起点就是0—wordLen之间。

```java
/*
 * @lc app=leetcode.cn id=30 lang=java
 *
 * [30] 串联所有单词的子串
 */

// @lc code=start
/* 
 * 思路：统计窗口中的字串中的单词是否想同
 * 单词长度固定的，
 * 我们可以计算出截取字符串的单词个数是否和 words 里相等，
 * 所以我们可以借用哈希表。
 * 
 * 
 * 滑动窗口，在s中维护一个所有单词长度长的窗口
 */

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> ans = new ArrayList<>();
        int wordLen = words[0].length();
        int wordNum = words.length;
        int sLen = s.length();
        if(wordLen * wordNum > sLen) return ans;
        Map<String, Integer> wordCountMap  = new HashMap<>();
        // 统计words，每个单词出现的次数
        for(String word : words) {
            wordCountMap.put(word, wordCountMap.getOrDefault(word, 0) + 1);
        }
        // 滑动窗口
        /* 
         * 
         * 使用窗口， 统计窗口内出现的单词次数。
         * 滑动窗口的起点可以固定位一个单词的长度
         * 因为一个单词之后的窗口都是重复的
         * 比如"barfoofoobarthefoobarman", words = ["bar","foo","the"]，
         * 第一层for循环是枚举每个在s中滑动窗口的起始位置 i，
         * 按照正常思路来讲，这个 i 应该在范围[0, sLength-wordLenth]，
         * 但其实这会造成很多重复的结果，比如，当 i = 0的时候，
         * 单词的划分为 bar | foo | foo | bar | the | foo | bar | man，
         * 当 i = 3（或者其他单词长度的整数倍情况，比如 6，9...）, 
         * 这个时候 i < 3 的字符是在滑动窗口之外的，
         * 所以单词的划分为 foo | foo | bar | the | foo | bar | man，
         * 你会发现当i = 0的时候，已经包含了 i = 3的时候情况，
         * 所以这两个结果其实是重复的，
         * 不难看出，i= 0 的情况包含了 i =3, 6，9，12....的情况，
         * 同理，i = 1，包含了 i = 4, 7, 10, 13...的情况， 
         * i = 2包含了 i = 5，8，11，14的情况，
         * 所以窗口的起始遍历长度只需要单词的长度范围，即 0~3的范围。
         */
        for(int winStart = 0; winStart < wordLen; winStart++) {
            int l = winStart;
            int r = winStart;
            // 统计当前窗口内的单词个数
            Map<String, Integer> winCountMap = new HashMap<>();
            // 开始移动右窗口边界
            // 这里必须是等于，ab ab 0 + 2 = 2, 2 + 2 = 4
            while (r + wordLen <= sLen) {
                //新加入窗口的单词
                String newWord = s.substring(r, r + wordLen);
                winCountMap.put(newWord, winCountMap.getOrDefault(newWord, 0) + 1);
                r += wordLen;
                // 处理左边界的情况
                /* 
                 * 1. 新加入的单词不在words数组中
                 * 
                 * 2. 新加入的单词的个数已经超过了
                 * 
                 */

                 // 两种情况都是newWord的次数 > words数组中统计的次数
                 while(winCountMap.getOrDefault(newWord, 0) > wordCountMap.getOrDefault(newWord, 0)) {
                    if(l == r || l >= sLen) {
                        break;
                    }
                    String leftWord = s.substring(l, l + wordLen);
                    winCountMap.put(leftWord, winCountMap.getOrDefault(leftWord, 0) - 1);
                    l += wordLen;
                 }

                 int num = (r - l) / wordLen;
                 if(num == wordNum) {
                    ans.add(l);
                 }
            }
        }
        return ans;
    }
}
// @lc code=end


```

# 链表

## [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

 

**提示：**

- 链表中节点的数目范围是 `[0, 104]`
- `-105 <= Node.val <= 105`
- `pos` 为 `-1` 或者链表中的一个 **有效索引** 。

 

**进阶：**你能用 `O(1)`（即，常量）内存解决此问题吗？

思路：

```java
/*
 * @lc app=leetcode.cn id=141 lang=java
 *
 * [141] 环形链表
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
/* 
 * 最简单的方法，使用map记录经过的结点
 * 但是题目要求使用O(1)的内存，所以需要使用快慢指针,
 * 一个一次走一步，
 * 一个一次走两步
 */
 
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null) return false;
        ListNode fast = head.next;
        ListNode slow = head;
        while (fast != slow) {
            // 这里需要特别注意判断fast.next是否为null，不然fast.next.next报错
            if(fast == null || fast.next == null) return false;
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
// @lc code=end


```

## [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

easy

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```
输入：l1 = [], l2 = [0]
输出：[0]
```

 

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

思路：使用迭代法，还可以递归。

```java
/*
 * @lc app=leetcode.cn id=21 lang=java
 *
 * [21] 合并两个有序链表
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode head = new ListNode();
        ListNode f1 = head;
        while(list1 != null && list2 != null) {
            if(list1.val <= list2.val) {
                f1.next = list1;
                list1 = list1.next;
            } else {
                f1.next = list2;
                list2 = list2.next;
            }
            // 移动f1到下一个
            f1 = f1.next;
        }
        if(list1 != null) {
            f1.next = list1;
        }
        if(list2 != null) {
            f1.next = list2;
        }
        return head == null ? head : head.next;
    }
}

```

## [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

 

**提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

思路：使用模拟的方法，==需要注意的是最后进位的处理==。

```java
/*
 * @lc app=leetcode.cn id=2 lang=java
 *
 * [2] 两数相加
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int nextSum = 0;
        ListNode f1 = l1;
        ListNode f2 = l2;
        while(f1 != null && f2 != null) {
            int sum = f1.val + f2.val + nextSum;
            f1.val = sum % 10;
            nextSum = sum / 10;
            if(f1.next == null) {
                f1.next = f2.next;
                break;
            }
            if(f2.next == null) {
                break;
            }
            f1 = f1.next;
            f2 = f2.next;
        }
        while(nextSum != 0 && f1.next != null) {
            f1 = f1.next;
            int sum = f1.val + nextSum;
            f1.val = sum % 10;
            nextSum = sum / 10;
        }
        if(nextSum != 0) {
            f1.next = new ListNode(nextSum);
        }
        return l1;
    }
}
// @lc code=end
```

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode head = null, tail = null;
        int carry = 0;
        while (l1 != null || l2 != null) {
            int n1 = l1 != null ? l1.val : 0;
            int n2 = l2 != null ? l2.val : 0;
            int sum = n1 + n2 + carry;
            if (head == null) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail.next = new ListNode(sum % 10);
                tail = tail.next;
            }
            carry = sum / 10;
            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }
        if (carry > 0) {
            tail.next = new ListNode(carry);
        }
        return head;
    }
}

作者：力扣官方题解
链接：https://leetcode.cn/problems/add-two-numbers/solutions/435246/liang-shu-xiang-jia-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

**示例 2：**

```
输入：head = [5], left = 1, right = 1
输出：[5]
```

 

**提示：**

- 链表中节点数目为 `n`
- `1 <= n <= 500`
- `-500 <= Node.val <= 500`
- `1 <= left <= right <= n`

 

**进阶：** 你可以使用一趟扫描完成反转吗？

思路：

先遍历到需要反转的前一个节点，因为最后我们是需要这个节点做处理的。==p0那里不要断，需要用它找它的next==

![image-20240815112649798](https://aliyun-imgbed.oss-cn-beijing.aliyuncs.com/img/image-20240815112649798.png)

```java
/*
 * @lc app=leetcode.cn id=92 lang=java
 *
 * [92] 反转链表 II
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        /* 
         * 我们需要设置一个虚拟头节点，方便处理left == 1的情况
         * 
         */
        ListNode pHead = new ListNode(-1);
        pHead.next = head;
        // 需要反转的前一个节点
        ListNode p0 = pHead;
        // 遍历到left - 1处
        for(int i = 1; i <= left - 1; i++) {
            p0 = p0.next;
        }
        // 开始使用反转链表的思路
        ListNode prev = null;
        ListNode cur = p0.next;
        // 头插区域之间的
        for(int i = left; i <= right; i++) {
            ListNode next = cur.next;
            cur.next = prev;
            prev = cur;
            cur = next;
        }
        // 关键, 画图理解
        p0.next.next = cur;
        p0.next = prev;
        return pHead.next;
    }
}
// @lc code=end

```

## [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`：一个表示 `Node.val` 的整数。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

**示例 3：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)**

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

 

**提示：**

- `0 <= n <= 1000`
- `-104 <= Node.val <= 104`
- `Node.random` 为 `null` 或指向链表中的节点。

思路：

```java
/*
 * @lc app=leetcode.cn id=138 lang=java
 *
 * [138] 随机链表的复制
 */

// @lc code=start
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

import java.util.HashMap;
import java.util.Map;


// 递归法 + hashMap
class Solution {
    Map<Node, Node> map = new HashMap<>();
    public Node copyRandomList(Node head) {
        if(head == null) return head;
        //  如果map中有了，则不需要创新的了
        if(!map.containsKey(head)) {
            Node newNode = new Node(head.val);
            map.put(head, newNode);
            // 先对next复制
            newNode.next = copyRandomList(head.next);
            //next复制玩，开始进行random 的复制
            newNode.random = copyRandomList(head.random);
        }
        return map.get(head);
    }
}
// @lc code=end


```

```java
// 迭代法 + hashMap
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;
        Node cur = head;
        Map<Node, Node> map = new HashMap<>();
        // 3. 复制各节点，并建立 “原节点 -> 新节点” 的 Map 映射
        while(cur != null) {
            map.put(cur, new Node(cur.val));
            cur = cur.next;
        }
        cur = head;
        // 4. 构建新链表的 next 和 random 指向
        while(cur != null) {
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        // 5. 返回新链表的头节点
        return map.get(head);
    }
}
```

![image-20240815144225475](https://aliyun-imgbed.oss-cn-beijing.aliyuncs.com/img/image-20240815144225475.png)

```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;
        Node cur = head;
        // 1. 复制各节点，并构建拼接链表
        while(cur != null) {
            Node tmp = new Node(cur.val);
            tmp.next = cur.next;
            cur.next = tmp;
            cur = tmp.next;
        }
        // 2. 构建各新节点的 random 指向
        cur = head;
        while(cur != null) {
            if(cur.random != null)
                cur.next.random = cur.random.next;
            cur = cur.next.next;
        }
        // 3. 拆分两链表
        cur = head.next;
        Node pre = head, res = head.next;
        while(cur.next != null) {
            pre.next = pre.next.next;
            cur.next = cur.next.next;
            pre = pre.next;
            cur = cur.next;
        }
        pre.next = null; // 单独处理原链表尾节点
        return res;      // 返回新链表头节点
    }
}
```

## [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**示例 2：**

```
输入：head = [1], n = 1
输出：[]
```

**示例 3：**

```
输入：head = [1,2], n = 1
输出：[1]
```

 

**提示：**

- 链表中结点的数目为 `sz`
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

 

**进阶：**你能尝试使用一趟扫描实现吗？

```java
class Solution {
    // 使用map记录n-th对应的节点
    public ListNode removeNthFromEnd(ListNode head, int n) {
        Map<Integer,ListNode> map = new HashMap<>();
        int count = 0;
        // 添加虚拟头节点，方便删除
        ListNode dummy = new ListNode(-1, head);
        map.put(0,dummy);
        ListNode p0 = head;
        while(p0 != null) {
            map.put(++count,p0);
            p0 = p0.next;
        }
        int needToDe = count - n + 1;
        ListNode nodeNxt = map.get(needToDe + 1);
        ListNode nodePrev = map.get(needToDe - 1);
        nodePrev.next = nodeNxt;
        return dummy.next;
    }
}
```

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0, head);
        Deque<ListNode> stack = new LinkedList<ListNode>();
        ListNode cur = dummy;
        while (cur != null) {
            stack.push(cur);
            cur = cur.next;
        }
        for (int i = 0; i < n; ++i) {
            stack.pop();
        }
        ListNode prev = stack.peek();
        prev.next = prev.next.next;
        ListNode ans = dummy.next;
        return ans;
    }
}
作者：力扣官方题解
链接：https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solutions/450350/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

整体思路是让前面的指针先移动 n 步，之后前后指针共同移动直到前面的指针到尾部为止

首先设立预先指针 pre，预先指针是一个小技巧，在第 2 题中进行了讲解

设预先指针 pre 的下一个节点指向 head，设前指针为 start，后指针为 end，二者都等于 pre

start 先向前移动n步

==之后 start 和 end 共同向前移动，此时二者的距离为 n，当 start 到尾部时，end 的位置恰好为倒数第 n 个节点
因为要删除该节点，所以要移动到该节点的前一个才能删除，所以循环结束条件为 start.next != null==

![image-20240819110221528](https://aliyun-imgbed.oss-cn-beijing.aliyuncs.com/img/image-20240819110221528.png)

删除后返回 pre.next，为什么不直接返回 head 呢，因为 head 有可能是被删掉的点
时间复杂度：O(n)

```java
//双指针
class Solution {
    // 使用双指针
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 使用虚拟头节点处理真正头节点的情况
        ListNode dummy = new ListNode(0,head);
        ListNode start = dummy, end = dummy;
        // 想让start走n步
         while(n != 0) {
            start = start.next;
            n--;
        }
        // 然后start和end同时开始走，让end保持在待删除节点的前一个节点
        // start.next != null就是为了保证他在前一个节点
        while(start.next != null) {
            start = start.next;
            end = end.next;
        }
        end.next = end.next.next;
        return dummy.next;
    }
}
```

## [61. 旋转链表](https://leetcode.cn/problems/rotate-list/)

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg)

```
输入：head = [0,1,2], k = 4
输出：[2,0,1]
```

 

**提示：**

- 链表中节点的数目在范围 `[0, 500]` 内
- `-100 <= Node.val <= 100`
- `0 <= k <= 2 * 109`

记给定链表的长度为 n，注意到当向右移动的次数 k≥n 时，我们仅需要向右移动 k mod n 次即可。因为每 n 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第 n − k mod n 个节点（从 01开始计数）。

这样，我们可以先将给定的链表连接成环，然后将指定位置断开。

具体代码中，我们首先计算出链表的长度 n，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点 n − k mod n 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。

特别地，当链表长度不大于 1，或者 k 为 n 的倍数时，新链表将与原链表相同，我们无需进行任何处理。

```java
class Solution {
    // 使用连成环的思想
    public ListNode rotateRight(ListNode head, int k) {
        // 特殊情况处理
        if (k == 0 || head == null || head.next == null) {
            return head;
        }
        ListNode p0 = head;
        int n = 1;
        //统计链表的长度
        while(p0.next != null) {
            n++;
            p0 = p0.next;
        }
        // 新链表的最后一个节点
        int add = n - k % n;
        // 不需要旋转
        if(add == n) {
            return head;
        }
        // 首尾相连形成环
        p0.next = head;
        // 寻找断尾处
        while(add > 0) {
            p0 = p0.next;
            add--;
        }
        ListNode h = p0.next;
        p0.next = null;
        return h;
    }
}
```

## [86. 分隔链表](https://leetcode.cn/problems/partition-list/)

给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，==使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前==。

你应当 **保留** 两个分区中每个节点的初始相对位置。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/04/partition.jpg)

```
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```

**示例 2：**

```
输入：head = [2,1], x = 2
输出：[1,2]
```

 

**提示：**

- 链表中节点的数目在范围 `[0, 200]` 内
- `-100 <= Node.val <= 100`
- `-200 <= x <= 200`

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    /**
        思路：新建两个链表，一个保存小于x的，一个保存大于x
        然后拼接即可
     */
    public ListNode partition(ListNode head, int x) {
        ListNode dummySmall = new ListNode(-1);
        ListNode dummyBigger = new ListNode(-1);
        // 用于添加节点的临时变量
        ListNode sml = dummySmall, big = dummyBigger;
        while(head != null) {
            if (head.val < x) {
                sml.next = head;
                sml = sml.next;
            } else {
                big.next = head;
                big = big.next;
            }
            head = head.next;
        }
        sml.next = dummyBigger.next;
        // 可能之间还有连接，需要断去
        //4->1->2->3，如果不断去就会新成
        big.next = null;
        return dummySmall.next;
    }
}
```

## [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

 

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

 

**提示：**

- `1 <= capacity <= 3000`
- `0 <= key <= 10000`
- `0 <= value <= 105`
- 最多调用 `2 * 105` 次 `get` 和 `put`

1. 调用api

   ```java
   class LRUCache extends LinkedHashMap<Integer, Integer>{
       private int capacity;
       
       public LRUCache(int capacity) {
           super(capacity, 0.75F, true);
           this.capacity = capacity;
       }
   
       public int get(int key) {
           return super.getOrDefault(key, -1);
       }
   
       public void put(int key, int value) {
           super.put(key, value);
       }
   
       // 查出最大容量后自动移除最旧的值
       @Override
       protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
           return size() > capacity; 
       }
   }
   ```

   思路：

   >既然需要移除最旧的数据，并需要移动使用过的数据为最新，我们就需要知道头和尾，所以我们可以采用双向链表的方式，而需要做到随机提取数据，我们就需要一个Map记录。
   >
   >为什么不采用数组的形式，是因为我们需要移动数据，所以采用Map来记录，空间换时间。

   ```java
   class LRUCache {
       //定义Node
       class LinkNode {
           int key;
           int value;
           LinkNode prev = null;
           LinkNode next = null;
           public LinkNode() {};
           public LinkNode(int key_, int val_) {
               key = key_;
               value = val_;
           };
   
   
       }
       // 通过key找到Node
       private Map<Integer, LinkNode> cache = new HashMap<>();
       private int capacity;
       // 当前的大小
       private int size;
       //虚拟 头尾节点
       private LinkNode head, tail;
       public LRUCache(int capacity) {
           this.capacity = capacity;
           this.size = 0;
           this.head = new LinkNode();
           this.tail = new LinkNode();
           this.head.next = this.tail;
           this.tail.prev = this.head;
       }
       public int get(int key) {
           LinkNode node = cache.get(key);
           if(node != null) {
               // 采用的是头插法，所以放在头部的数据是最新的
               moveToHead(node);
               return node.value;
           }
           return -1;
       }
       public void put(int key, int value) {
           LinkNode node = cache.get(key);
           if(node == null) {
               // 没有这个数据
               LinkNode newNode = new LinkNode(key,value);
               // 添加进哈希表
               cache.put(key, newNode);
               // 添加至双向链表的头部
               addToHead(newNode);
               size++;
               // 如果超出最大的容量
               if(size > capacity) {
                   // 需要删除尾节点;
                   LinkNode tailPrev = tail.prev;
                   removeNode(tailPrev);
                   cache.remove(tailPrev.key);
                   size--;
               }
           } else {
               //有这个数据
               node.value = value;
               // 更新为最新使用的
               moveToHead(node);
           }
       }
       public void addToHead(LinkNode node) {
           node.prev = head;
           node.next = head.next;
           head.next.prev = node;
           head.next = node;
       }
   
       public void moveToHead(LinkNode node) {
           removeNode(node);
           addToHead(node);
       }
       // 抽出一个删除节点的算法
        private void removeNode(LinkNode node) {
           node.prev.next = node.next;
           node.next.prev = node.prev;
       }
   }
   
   /**
    * Your LRUCache object will be instantiated and called as such:
    * LRUCache obj = new LRUCache(capacity);
    * int param_1 = obj.get(key);
    * obj.put(key,value);
    */
   ```

   ## [82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

   

   给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

    

   **示例 1：**

   ![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)

   ```
   输入：head = [1,2,3,3,4,4,5]
   输出：[1,2,5]
   ```

   **示例 2：**

   ![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)

   ```
   输入：head = [1,1,1,2,3]
   输出：[2,3]
   ```

    

   **提示：**

   - 链表中节点数目在范围 `[0, 300]` 内
   - `-100 <= Node.val <= 100`
   - 题目数据保证链表已经按升序 **排列**

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode() {}
    *     ListNode(int val) { this.val = val; }
    *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    * }
    */
   class Solution {
       public ListNode deleteDuplicates(ListNode head) {
           if(head == null) {
               return null;
           }
           ListNode dummy = new ListNode(-1,head);
           ListNode cur = dummy;
           while(cur.next != null && cur.next.next != null) {
               if(cur.next.val == cur.next.next.val) {
                   int x = cur.next.val;
                   // 遍历后续的是否相同
                   while(cur.next != null && cur.next.val == x) {
                       cur.next = cur.next.next;
                   }
               } else {
                   cur = cur.next;
               }
           }
           return dummy.next;
       }
   }
   
   
   //双指针
   class Solution {
       public ListNode deleteDuplicates(ListNode head) {
           if(head == null) return null;
           ListNode dummyHead = new ListNode(-101);
           ListNode pre = dummyHead;
           pre.next = head;
           ListNode cur = head;
           while(cur != null && cur.next != null){
               if(cur.val == cur.next.val){
                   int val = cur.val;
                   // 跳过所有相同项
                   while(cur != null && cur.val == val){
                       cur = cur.next;
                   }
                   pre.next = cur;
               }else{
                   pre = cur;
                   cur = cur.next;
               }
           }
           return dummyHead.next;
       }
   }
   ```

   ## [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

```
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```

 

**提示：**

- 链表中的节点数目为 `n`
- `1 <= k <= n <= 5000`
- `0 <= Node.val <= 1000`

 

**进阶：**你可以设计一个只用 `O(1)` 额外内存空间的算法解决此问题吗？



思路：反转局部，然后连接。需要注意的是虚拟节点的处理和保存节点。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {

    public ListNode reverseKGroup(ListNode head, int k) {
        // k = 1, 相当于不反转
        if(k == 1 || head == null) return head;
        //加一个dummy，用于处理第一个节点
        ListNode dummy = new ListNode(-1,head);
        ListNode p0 = head;
        // 思路，就和之前反转中间某一段的链表的思路是一样的
        // 待反转区间前一个节点
        ListNode pre = dummy;

        // 获取链表的长度
        int len = 0;
        while(p0 != null) {
            p0 = p0.next;
            len++;
        }
        // 开始反转，preCur是反转节点的前一个节点
        ListNode preCur = null;
        ListNode cur = head;
        while(len >= k) {
            int t = k;
            // 不用担心null的问题，因为长度已经保证了
            while(t-- > 0) {
                ListNode tmp = cur.next;
                cur.next = preCur;
                preCur = cur;
                cur = tmp;
            }
            // 保存
            ListNode tmp = pre.next;
            //连接前后关系
            pre.next.next = cur;
            pre.next = preCur;
            // 重置条件
            preCur = null;
            pre = tmp;
            len -= k;
        }
        return dummy.next;
    }   
}
```

# 二叉树

## [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

 

```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

**示例 2：**

```
输入：root = [1,null,2]
输出：2
```

 

**提示：**

- 树中节点的数量在 `[0, 104]` 区间内。
- `-100 <= Node.val <= 100`

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
// 思路；dfs即可，ans = max(l,r);
class Solution {
    public int solve(TreeNode root,int c) {
        if(root == null) {
            return c;
        }
        int l = solve(root.left, c + 1);
        int r = solve(root.right, c + 1);
        return l > r ? l: r;
    }
    public int maxDepth(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int ans = solve(root,0);
        return ans;
    }
}
```

## [100. 相同的树](https://leetcode.cn/problems/same-tree/)

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)

```
输入：p = [1,2,3], q = [1,2,3]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)

```
输入：p = [1,2], q = [1,null,2]
输出：false
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)

```
输入：p = [1,2,1], q = [1,1,2]
输出：false
```

 

**提示：**

- 两棵树上的节点数目都在范围 `[0, 100]` 内
- `-104 <= Node.val <= 104`

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
// 思路：递归判断左边和右边就好，最后判断左右都是否相同
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null) {
            return true;
        }
        if(p != null && q != null) {
            if(p.val == q.val) {
                boolean l = isSameTree(p.left, q.left);
                boolean r = isSameTree(p.right, q.right);
                return l && r;
            } 
        }
        return false;
    }
}
```

## [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```

 

**提示：**

- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        // 后序遍历
        if(root == null) return root;
        TreeNode l = invertTree(root.left);
        TreeNode r = invertTree(root.right);
        root.left = r;
        root.right = l;
        return root;
    }
}
```

## [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 

**示例 1：**

![img](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

 

**提示：**

- 树中节点数目在范围 `[1, 1000]` 内
- `-100 <= Node.val <= 100`

 

**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
 // 递归法
class Solution {
    public boolean solve(TreeNode l, TreeNode r) {
        if(l == null && r == null) {
            return true;
        }
        if(l != null && r != null) {
            if(l.val == r.val) {
                // 这里是反的，需要注意处理
                return solve(l.left, r.right) && solve(l.right, r.left);
            }
        }
        // 其他情况都返回false
        return false;
    }
    public boolean isSymmetric(TreeNode root) {
        if(root == null) {
            return true;
        }
        // 分成两颗树
        return solve(root.left, root.right);
    }
}
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
 // 迭代法

// 自己想到的是用bfs遍历
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root, root);
    }

    public boolean check(TreeNode u, TreeNode v) {
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        q.offer(u);
        q.offer(v);
        while (!q.isEmpty()) {
            u = q.poll();
            v = q.poll();
            if (u == null && v == null) {
                continue;
            }
            if ((u == null || v == null) || (u.val != v.val)) {
                return false;
            }

            q.offer(u.left);
            q.offer(v.right);

            q.offer(u.right);
            q.offer(v.left);
        }
        return true;
    }
}
```

## [112. 路径总和](https://leetcode.cn/problems/path-sum/)

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

**示例 3：**

```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```

 

**提示：**

- 树中节点的数目在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

 // 需要注意的是叶子节点是没有子节点的节点，而不是判断一个节点是null，就返回
class Solution {
    public boolean solve(TreeNode root, int nowSum, int targetSum) {
        // 在这个判读中不可能到达这一步的
        // if(root == null) {
        //     return false;
        // }
        TreeNode l = root.left;
        TreeNode r = root.right;
        if(l == null && r == null) {
            if(nowSum == targetSum) return true;
            return false;
        }
        // 一定要判断是否为空
        boolean leftRes = l != null && solve(l, nowSum + l.val, targetSum);
        if(leftRes) return leftRes;
        return r != null && solve(r, nowSum + r.val, targetSum);
    }
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        return solve(root, root.val, targetSum);
    }
}
```

```java
// 官方题解

class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return sum == root.val;
        }
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}
```

## ==[114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)==

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [0]
输出：[0]
```

 

**提示：**

- 树中结点数在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

 

**进阶：**你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？

[114. 二叉树展开为链表 - 力扣（LeetCode）](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solutions/17274/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/?envType=study-plan-v2&envId=top-interview-150)

解法一
可以发现展开的顺序其实就是二叉树的先序遍历。算法和 94 题中序遍历的 Morris 算法有些神似，我们需要两步完成这道题。

将左子树插入到右子树的地方
将原来的右子树接到左子树的最右边节点
考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null
可以看图理解下这个过程。

Java
    1
   / \
  2   5
 / \   \
3   4   6

//将 1 的左子树插入到右子树的地方
    1
     \
      2         5
     / \         \
    3   4         6        
//将原来的右子树接到左子树的最右边节点
    1
     \
      2          
     / \          
    3   4  
         \
          5
           \
            6
            
 //将 2 的左子树插入到右子树的地方
    1
     \
      2          
       \          
        3       4  
                 \
                  5
                   \
                    6   
        
 //将原来的右子树接到左子树的最右边节点
    1
     \
      2          
       \          
        3      
         \
          4  
           \
            5
             \
              6         

  ......

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
   public void flatten(TreeNode root) {
    while (root != null) { 
        //左子树为 null，直接考虑下一个节点
        if (root.left == null) {
            root = root.right;
        } else {
            // 找左子树最右边的节点
            TreeNode pre = root.left;
            while (pre.right != null) {
                pre = pre.right;
            } 
            //将原来的右子树接到左子树的最右边节点
            pre.right = root.right;
            // 将左子树插入到右子树的地方
            root.right = root.left;
            root.left = null;
            // 考虑下一个节点
            root = root.right;
        }
    }
}
}
```

