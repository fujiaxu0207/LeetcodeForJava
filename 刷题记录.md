# 滑动窗口

## [30. 串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)

给定一个字符串 `s` 和一个字符串数组 `words`**。** `words` 中所有字符串 **长度相同**。

 `s` 中的 **串联子串** 是指一个包含 `words` 中所有字符串以任意顺序排列连接起来的子串。

- 例如，如果 `words = ["ab","cd","ef"]`， 那么 `"abcdef"`， `"abefcd"`，`"cdabef"`， `"cdefab"`，`"efabcd"`， 和 `"efcdab"` 都是串联子串。 `"acdbef"` 不是串联子串，因为他不是任何 `words` 排列的连接。

返回所有串联子串在 `s` 中的开始索引。你可以以 **任意顺序** 返回答案。

 

**示例 1：**

```
输入：s = "barfoothefoobarman", words = ["foo","bar"]
输出：[0,9]
解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。
子串 "barfoo" 开始位置是 0。它是 words 中以 ["bar","foo"] 顺序排列的连接。
子串 "foobar" 开始位置是 9。它是 words 中以 ["foo","bar"] 顺序排列的连接。
输出顺序无关紧要。返回 [9,0] 也是可以的。
```

**示例 2：**

```
输入：s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]
输出：[]
解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。
s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。
所以我们返回一个空数组。
```

**示例 3：**

```
输入：s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]
输出：[6,9,12]
解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。
子串 "foobarthe" 开始位置是 6。它是 words 中以 ["foo","bar","the"] 顺序排列的连接。
子串 "barthefoo" 开始位置是 9。它是 words 中以 ["bar","the","foo"] 顺序排列的连接。
子串 "thefoobar" 开始位置是 12。它是 words 中以 ["the","foo","bar"] 顺序排列的连接。
```

思路：因为单词长度相同，那么只要确定一个窗口长度，那么就可以划分若干个唯一的单词，统计窗口内的单词个数，就可以判断了。需要注意的是窗口起点就是0—wordLen之间。

```java
/*
 * @lc app=leetcode.cn id=30 lang=java
 *
 * [30] 串联所有单词的子串
 */

// @lc code=start
/* 
 * 思路：统计窗口中的字串中的单词是否想同
 * 单词长度固定的，
 * 我们可以计算出截取字符串的单词个数是否和 words 里相等，
 * 所以我们可以借用哈希表。
 * 
 * 
 * 滑动窗口，在s中维护一个所有单词长度长的窗口
 */

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> ans = new ArrayList<>();
        int wordLen = words[0].length();
        int wordNum = words.length;
        int sLen = s.length();
        if(wordLen * wordNum > sLen) return ans;
        Map<String, Integer> wordCountMap  = new HashMap<>();
        // 统计words，每个单词出现的次数
        for(String word : words) {
            wordCountMap.put(word, wordCountMap.getOrDefault(word, 0) + 1);
        }
        // 滑动窗口
        /* 
         * 
         * 使用窗口， 统计窗口内出现的单词次数。
         * 滑动窗口的起点可以固定位一个单词的长度
         * 因为一个单词之后的窗口都是重复的
         * 比如"barfoofoobarthefoobarman", words = ["bar","foo","the"]，
         * 第一层for循环是枚举每个在s中滑动窗口的起始位置 i，
         * 按照正常思路来讲，这个 i 应该在范围[0, sLength-wordLenth]，
         * 但其实这会造成很多重复的结果，比如，当 i = 0的时候，
         * 单词的划分为 bar | foo | foo | bar | the | foo | bar | man，
         * 当 i = 3（或者其他单词长度的整数倍情况，比如 6，9...）, 
         * 这个时候 i < 3 的字符是在滑动窗口之外的，
         * 所以单词的划分为 foo | foo | bar | the | foo | bar | man，
         * 你会发现当i = 0的时候，已经包含了 i = 3的时候情况，
         * 所以这两个结果其实是重复的，
         * 不难看出，i= 0 的情况包含了 i =3, 6，9，12....的情况，
         * 同理，i = 1，包含了 i = 4, 7, 10, 13...的情况， 
         * i = 2包含了 i = 5，8，11，14的情况，
         * 所以窗口的起始遍历长度只需要单词的长度范围，即 0~3的范围。
         */
        for(int winStart = 0; winStart < wordLen; winStart++) {
            int l = winStart;
            int r = winStart;
            // 统计当前窗口内的单词个数
            Map<String, Integer> winCountMap = new HashMap<>();
            // 开始移动右窗口边界
            // 这里必须是等于，ab ab 0 + 2 = 2, 2 + 2 = 4
            while (r + wordLen <= sLen) {
                //新加入窗口的单词
                String newWord = s.substring(r, r + wordLen);
                winCountMap.put(newWord, winCountMap.getOrDefault(newWord, 0) + 1);
                r += wordLen;
                // 处理左边界的情况
                /* 
                 * 1. 新加入的单词不在words数组中
                 * 
                 * 2. 新加入的单词的个数已经超过了
                 * 
                 */

                 // 两种情况都是newWord的次数 > words数组中统计的次数
                 while(winCountMap.getOrDefault(newWord, 0) > wordCountMap.getOrDefault(newWord, 0)) {
                    if(l == r || l >= sLen) {
                        break;
                    }
                    String leftWord = s.substring(l, l + wordLen);
                    winCountMap.put(leftWord, winCountMap.getOrDefault(leftWord, 0) - 1);
                    l += wordLen;
                 }

                 int num = (r - l) / wordLen;
                 if(num == wordNum) {
                    ans.add(l);
                 }
            }
        }
        return ans;
    }
}
// @lc code=end


```

# 链表

## [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

 

**提示：**

- 链表中节点的数目范围是 `[0, 104]`
- `-105 <= Node.val <= 105`
- `pos` 为 `-1` 或者链表中的一个 **有效索引** 。

 

**进阶：**你能用 `O(1)`（即，常量）内存解决此问题吗？

思路：

```java
/*
 * @lc app=leetcode.cn id=141 lang=java
 *
 * [141] 环形链表
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
/* 
 * 最简单的方法，使用map记录经过的结点
 * 但是题目要求使用O(1)的内存，所以需要使用快慢指针,
 * 一个一次走一步，
 * 一个一次走两步
 */
 
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null) return false;
        ListNode fast = head.next;
        ListNode slow = head;
        while (fast != slow) {
            // 这里需要特别注意判断fast.next是否为null，不然fast.next.next报错
            if(fast == null || fast.next == null) return false;
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
// @lc code=end


```

## [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

easy

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```
输入：l1 = [], l2 = [0]
输出：[0]
```

 

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

思路：使用迭代法，还可以递归。

```java
/*
 * @lc app=leetcode.cn id=21 lang=java
 *
 * [21] 合并两个有序链表
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode head = new ListNode();
        ListNode f1 = head;
        while(list1 != null && list2 != null) {
            if(list1.val <= list2.val) {
                f1.next = list1;
                list1 = list1.next;
            } else {
                f1.next = list2;
                list2 = list2.next;
            }
            // 移动f1到下一个
            f1 = f1.next;
        }
        if(list1 != null) {
            f1.next = list1;
        }
        if(list2 != null) {
            f1.next = list2;
        }
        return head == null ? head : head.next;
    }
}

```

## [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

 

**提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

思路：使用模拟的方法，==需要注意的是最后进位的处理==。

```java
/*
 * @lc app=leetcode.cn id=2 lang=java
 *
 * [2] 两数相加
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int nextSum = 0;
        ListNode f1 = l1;
        ListNode f2 = l2;
        while(f1 != null && f2 != null) {
            int sum = f1.val + f2.val + nextSum;
            f1.val = sum % 10;
            nextSum = sum / 10;
            if(f1.next == null) {
                f1.next = f2.next;
                break;
            }
            if(f2.next == null) {
                break;
            }
            f1 = f1.next;
            f2 = f2.next;
        }
        while(nextSum != 0 && f1.next != null) {
            f1 = f1.next;
            int sum = f1.val + nextSum;
            f1.val = sum % 10;
            nextSum = sum / 10;
        }
        if(nextSum != 0) {
            f1.next = new ListNode(nextSum);
        }
        return l1;
    }
}
// @lc code=end
```

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode head = null, tail = null;
        int carry = 0;
        while (l1 != null || l2 != null) {
            int n1 = l1 != null ? l1.val : 0;
            int n2 = l2 != null ? l2.val : 0;
            int sum = n1 + n2 + carry;
            if (head == null) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail.next = new ListNode(sum % 10);
                tail = tail.next;
            }
            carry = sum / 10;
            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }
        if (carry > 0) {
            tail.next = new ListNode(carry);
        }
        return head;
    }
}

作者：力扣官方题解
链接：https://leetcode.cn/problems/add-two-numbers/solutions/435246/liang-shu-xiang-jia-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

**示例 2：**

```
输入：head = [5], left = 1, right = 1
输出：[5]
```

 

**提示：**

- 链表中节点数目为 `n`
- `1 <= n <= 500`
- `-500 <= Node.val <= 500`
- `1 <= left <= right <= n`

 

**进阶：** 你可以使用一趟扫描完成反转吗？

思路：

先遍历到需要反转的前一个节点，因为最后我们是需要这个节点做处理的。==p0那里不要断，需要用它找它的next==

![image-20240815112649798](https://aliyun-imgbed.oss-cn-beijing.aliyuncs.com/img/image-20240815112649798.png)

```java
/*
 * @lc app=leetcode.cn id=92 lang=java
 *
 * [92] 反转链表 II
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        /* 
         * 我们需要设置一个虚拟头节点，方便处理left == 1的情况
         * 
         */
        ListNode pHead = new ListNode(-1);
        pHead.next = head;
        // 需要反转的前一个节点
        ListNode p0 = pHead;
        // 遍历到left - 1处
        for(int i = 1; i <= left - 1; i++) {
            p0 = p0.next;
        }
        // 开始使用反转链表的思路
        ListNode prev = null;
        ListNode cur = p0.next;
        // 头插区域之间的
        for(int i = left; i <= right; i++) {
            ListNode next = cur.next;
            cur.next = prev;
            prev = cur;
            cur = next;
        }
        // 关键, 画图理解
        p0.next.next = cur;
        p0.next = prev;
        return pHead.next;
    }
}
// @lc code=end

```

## [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`：一个表示 `Node.val` 的整数。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

**示例 3：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)**

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

 

**提示：**

- `0 <= n <= 1000`
- `-104 <= Node.val <= 104`
- `Node.random` 为 `null` 或指向链表中的节点。

思路：

```java
/*
 * @lc app=leetcode.cn id=138 lang=java
 *
 * [138] 随机链表的复制
 */

// @lc code=start
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

import java.util.HashMap;
import java.util.Map;


// 递归法 + hashMap
class Solution {
    Map<Node, Node> map = new HashMap<>();
    public Node copyRandomList(Node head) {
        if(head == null) return head;
        //  如果map中有了，则不需要创新的了
        if(!map.containsKey(head)) {
            Node newNode = new Node(head.val);
            map.put(head, newNode);
            // 先对next复制
            newNode.next = copyRandomList(head.next);
            //next复制玩，开始进行random 的复制
            newNode.random = copyRandomList(head.random);
        }
        return map.get(head);
    }
}
// @lc code=end


```

```java
// 迭代法 + hashMap
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;
        Node cur = head;
        Map<Node, Node> map = new HashMap<>();
        // 3. 复制各节点，并建立 “原节点 -> 新节点” 的 Map 映射
        while(cur != null) {
            map.put(cur, new Node(cur.val));
            cur = cur.next;
        }
        cur = head;
        // 4. 构建新链表的 next 和 random 指向
        while(cur != null) {
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        // 5. 返回新链表的头节点
        return map.get(head);
    }
}
```

![image-20240815144225475](https://aliyun-imgbed.oss-cn-beijing.aliyuncs.com/img/image-20240815144225475.png)

```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;
        Node cur = head;
        // 1. 复制各节点，并构建拼接链表
        while(cur != null) {
            Node tmp = new Node(cur.val);
            tmp.next = cur.next;
            cur.next = tmp;
            cur = tmp.next;
        }
        // 2. 构建各新节点的 random 指向
        cur = head;
        while(cur != null) {
            if(cur.random != null)
                cur.next.random = cur.random.next;
            cur = cur.next.next;
        }
        // 3. 拆分两链表
        cur = head.next;
        Node pre = head, res = head.next;
        while(cur.next != null) {
            pre.next = pre.next.next;
            cur.next = cur.next.next;
            pre = pre.next;
            cur = cur.next;
        }
        pre.next = null; // 单独处理原链表尾节点
        return res;      // 返回新链表头节点
    }
}
```

## [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**示例 2：**

```
输入：head = [1], n = 1
输出：[]
```

**示例 3：**

```
输入：head = [1,2], n = 1
输出：[1]
```

 

**提示：**

- 链表中结点的数目为 `sz`
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

 

**进阶：**你能尝试使用一趟扫描实现吗？

```java
class Solution {
    // 使用map记录n-th对应的节点
    public ListNode removeNthFromEnd(ListNode head, int n) {
        Map<Integer,ListNode> map = new HashMap<>();
        int count = 0;
        // 添加虚拟头节点，方便删除
        ListNode dummy = new ListNode(-1, head);
        map.put(0,dummy);
        ListNode p0 = head;
        while(p0 != null) {
            map.put(++count,p0);
            p0 = p0.next;
        }
        int needToDe = count - n + 1;
        ListNode nodeNxt = map.get(needToDe + 1);
        ListNode nodePrev = map.get(needToDe - 1);
        nodePrev.next = nodeNxt;
        return dummy.next;
    }
}
```

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0, head);
        Deque<ListNode> stack = new LinkedList<ListNode>();
        ListNode cur = dummy;
        while (cur != null) {
            stack.push(cur);
            cur = cur.next;
        }
        for (int i = 0; i < n; ++i) {
            stack.pop();
        }
        ListNode prev = stack.peek();
        prev.next = prev.next.next;
        ListNode ans = dummy.next;
        return ans;
    }
}
作者：力扣官方题解
链接：https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solutions/450350/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

整体思路是让前面的指针先移动 n 步，之后前后指针共同移动直到前面的指针到尾部为止

首先设立预先指针 pre，预先指针是一个小技巧，在第 2 题中进行了讲解

设预先指针 pre 的下一个节点指向 head，设前指针为 start，后指针为 end，二者都等于 pre

start 先向前移动n步

==之后 start 和 end 共同向前移动，此时二者的距离为 n，当 start 到尾部时，end 的位置恰好为倒数第 n 个节点
因为要删除该节点，所以要移动到该节点的前一个才能删除，所以循环结束条件为 start.next != null==

![image-20240819110221528](https://aliyun-imgbed.oss-cn-beijing.aliyuncs.com/img/image-20240819110221528.png)

删除后返回 pre.next，为什么不直接返回 head 呢，因为 head 有可能是被删掉的点
时间复杂度：O(n)

```java
//双指针
class Solution {
    // 使用双指针
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 使用虚拟头节点处理真正头节点的情况
        ListNode dummy = new ListNode(0,head);
        ListNode start = dummy, end = dummy;
        // 想让start走n步
         while(n != 0) {
            start = start.next;
            n--;
        }
        // 然后start和end同时开始走，让end保持在待删除节点的前一个节点
        // start.next != null就是为了保证他在前一个节点
        while(start.next != null) {
            start = start.next;
            end = end.next;
        }
        end.next = end.next.next;
        return dummy.next;
    }
}
```

## [61. 旋转链表](https://leetcode.cn/problems/rotate-list/)

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg)

```
输入：head = [0,1,2], k = 4
输出：[2,0,1]
```

 

**提示：**

- 链表中节点的数目在范围 `[0, 500]` 内
- `-100 <= Node.val <= 100`
- `0 <= k <= 2 * 109`

记给定链表的长度为 n，注意到当向右移动的次数 k≥n 时，我们仅需要向右移动 k mod n 次即可。因为每 n 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第 n − k mod n 个节点（从 01开始计数）。

这样，我们可以先将给定的链表连接成环，然后将指定位置断开。

具体代码中，我们首先计算出链表的长度 n，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点 n − k mod n 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。

特别地，当链表长度不大于 1，或者 k 为 n 的倍数时，新链表将与原链表相同，我们无需进行任何处理。

```java
class Solution {
    // 使用连成环的思想
    public ListNode rotateRight(ListNode head, int k) {
        // 特殊情况处理
        if (k == 0 || head == null || head.next == null) {
            return head;
        }
        ListNode p0 = head;
        int n = 1;
        //统计链表的长度
        while(p0.next != null) {
            n++;
            p0 = p0.next;
        }
        // 新链表的最后一个节点
        int add = n - k % n;
        // 不需要旋转
        if(add == n) {
            return head;
        }
        // 首尾相连形成环
        p0.next = head;
        // 寻找断尾处
        while(add > 0) {
            p0 = p0.next;
            add--;
        }
        ListNode h = p0.next;
        p0.next = null;
        return h;
    }
}
```

## [86. 分隔链表](https://leetcode.cn/problems/partition-list/)

给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，==使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前==。

你应当 **保留** 两个分区中每个节点的初始相对位置。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/04/partition.jpg)

```
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```

**示例 2：**

```
输入：head = [2,1], x = 2
输出：[1,2]
```

 

**提示：**

- 链表中节点的数目在范围 `[0, 200]` 内
- `-100 <= Node.val <= 100`
- `-200 <= x <= 200`

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    /**
        思路：新建两个链表，一个保存小于x的，一个保存大于x
        然后拼接即可
     */
    public ListNode partition(ListNode head, int x) {
        ListNode dummySmall = new ListNode(-1);
        ListNode dummyBigger = new ListNode(-1);
        // 用于添加节点的临时变量
        ListNode sml = dummySmall, big = dummyBigger;
        while(head != null) {
            if (head.val < x) {
                sml.next = head;
                sml = sml.next;
            } else {
                big.next = head;
                big = big.next;
            }
            head = head.next;
        }
        sml.next = dummyBigger.next;
        // 可能之间还有连接，需要断去
        //4->1->2->3，如果不断去就会新成
        big.next = null;
        return dummySmall.next;
    }
}
```

## [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

 

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

 

**提示：**

- `1 <= capacity <= 3000`
- `0 <= key <= 10000`
- `0 <= value <= 105`
- 最多调用 `2 * 105` 次 `get` 和 `put`

1. 调用api

   ```java
   class LRUCache extends LinkedHashMap<Integer, Integer>{
       private int capacity;
       
       public LRUCache(int capacity) {
           super(capacity, 0.75F, true);
           this.capacity = capacity;
       }
   
       public int get(int key) {
           return super.getOrDefault(key, -1);
       }
   
       public void put(int key, int value) {
           super.put(key, value);
       }
   
       // 查出最大容量后自动移除最旧的值
       @Override
       protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
           return size() > capacity; 
       }
   }
   ```

   思路：

   >既然需要移除最旧的数据，并需要移动使用过的数据为最新，我们就需要知道头和尾，所以我们可以采用双向链表的方式，而需要做到随机提取数据，我们就需要一个Map记录。
   >
   >为什么不采用数组的形式，是因为我们需要移动数据，所以采用Map来记录，空间换时间。

   ```java
   class LRUCache {
       //定义Node
       class LinkNode {
           int key;
           int value;
           LinkNode prev = null;
           LinkNode next = null;
           public LinkNode() {};
           public LinkNode(int key_, int val_) {
               key = key_;
               value = val_;
           };
   
   
       }
       // 通过key找到Node
       private Map<Integer, LinkNode> cache = new HashMap<>();
       private int capacity;
       // 当前的大小
       private int size;
       //虚拟 头尾节点
       private LinkNode head, tail;
       public LRUCache(int capacity) {
           this.capacity = capacity;
           this.size = 0;
           this.head = new LinkNode();
           this.tail = new LinkNode();
           this.head.next = this.tail;
           this.tail.prev = this.head;
       }
       public int get(int key) {
           LinkNode node = cache.get(key);
           if(node != null) {
               // 采用的是头插法，所以放在头部的数据是最新的
               moveToHead(node);
               return node.value;
           }
           return -1;
       }
       public void put(int key, int value) {
           LinkNode node = cache.get(key);
           if(node == null) {
               // 没有这个数据
               LinkNode newNode = new LinkNode(key,value);
               // 添加进哈希表
               cache.put(key, newNode);
               // 添加至双向链表的头部
               addToHead(newNode);
               size++;
               // 如果超出最大的容量
               if(size > capacity) {
                   // 需要删除尾节点;
                   LinkNode tailPrev = tail.prev;
                   removeNode(tailPrev);
                   cache.remove(tailPrev.key);
                   size--;
               }
           } else {
               //有这个数据
               node.value = value;
               // 更新为最新使用的
               moveToHead(node);
           }
       }
       public void addToHead(LinkNode node) {
           node.prev = head;
           node.next = head.next;
           head.next.prev = node;
           head.next = node;
       }
   
       public void moveToHead(LinkNode node) {
           removeNode(node);
           addToHead(node);
       }
       // 抽出一个删除节点的算法
        private void removeNode(LinkNode node) {
           node.prev.next = node.next;
           node.next.prev = node.prev;
       }
   }
   
   /**
    * Your LRUCache object will be instantiated and called as such:
    * LRUCache obj = new LRUCache(capacity);
    * int param_1 = obj.get(key);
    * obj.put(key,value);
    */
   ```

   ## [82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

   

   给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

    

   **示例 1：**

   ![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)

   ```
   输入：head = [1,2,3,3,4,4,5]
   输出：[1,2,5]
   ```

   **示例 2：**

   ![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)

   ```
   输入：head = [1,1,1,2,3]
   输出：[2,3]
   ```

    

   **提示：**

   - 链表中节点数目在范围 `[0, 300]` 内
   - `-100 <= Node.val <= 100`
   - 题目数据保证链表已经按升序 **排列**

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode() {}
    *     ListNode(int val) { this.val = val; }
    *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    * }
    */
   class Solution {
       public ListNode deleteDuplicates(ListNode head) {
           if(head == null) {
               return null;
           }
           ListNode dummy = new ListNode(-1,head);
           ListNode cur = dummy;
           while(cur.next != null && cur.next.next != null) {
               if(cur.next.val == cur.next.next.val) {
                   int x = cur.next.val;
                   // 遍历后续的是否相同
                   while(cur.next != null && cur.next.val == x) {
                       cur.next = cur.next.next;
                   }
               } else {
                   cur = cur.next;
               }
           }
           return dummy.next;
       }
   }
   
   
   //双指针
   class Solution {
       public ListNode deleteDuplicates(ListNode head) {
           if(head == null) return null;
           ListNode dummyHead = new ListNode(-101);
           ListNode pre = dummyHead;
           pre.next = head;
           ListNode cur = head;
           while(cur != null && cur.next != null){
               if(cur.val == cur.next.val){
                   int val = cur.val;
                   // 跳过所有相同项
                   while(cur != null && cur.val == val){
                       cur = cur.next;
                   }
                   pre.next = cur;
               }else{
                   pre = cur;
                   cur = cur.next;
               }
           }
           return dummyHead.next;
       }
   }
   ```

   ## [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

```
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```

 

**提示：**

- 链表中的节点数目为 `n`
- `1 <= k <= n <= 5000`
- `0 <= Node.val <= 1000`

 

**进阶：**你可以设计一个只用 `O(1)` 额外内存空间的算法解决此问题吗？



思路：反转局部，然后连接。需要注意的是虚拟节点的处理和保存节点。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {

    public ListNode reverseKGroup(ListNode head, int k) {
        // k = 1, 相当于不反转
        if(k == 1 || head == null) return head;
        //加一个dummy，用于处理第一个节点
        ListNode dummy = new ListNode(-1,head);
        ListNode p0 = head;
        // 思路，就和之前反转中间某一段的链表的思路是一样的
        // 待反转区间前一个节点
        ListNode pre = dummy;

        // 获取链表的长度
        int len = 0;
        while(p0 != null) {
            p0 = p0.next;
            len++;
        }
        // 开始反转，preCur是反转节点的前一个节点
        ListNode preCur = null;
        ListNode cur = head;
        while(len >= k) {
            int t = k;
            // 不用担心null的问题，因为长度已经保证了
            while(t-- > 0) {
                ListNode tmp = cur.next;
                cur.next = preCur;
                preCur = cur;
                cur = tmp;
            }
            // 保存
            ListNode tmp = pre.next;
            //连接前后关系
            pre.next.next = cur;
            pre.next = preCur;
            // 重置条件
            preCur = null;
            pre = tmp;
            len -= k;
        }
        return dummy.next;
    }   
}
```

# 二叉树

## [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

 

```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

**示例 2：**

```
输入：root = [1,null,2]
输出：2
```

 

**提示：**

- 树中节点的数量在 `[0, 104]` 区间内。
- `-100 <= Node.val <= 100`

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
// 思路；dfs即可，ans = max(l,r);
class Solution {
    public int solve(TreeNode root,int c) {
        if(root == null) {
            return c;
        }
        int l = solve(root.left, c + 1);
        int r = solve(root.right, c + 1);
        return l > r ? l: r;
    }
    public int maxDepth(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int ans = solve(root,0);
        return ans;
    }
}
```

## [100. 相同的树](https://leetcode.cn/problems/same-tree/)

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)

```
输入：p = [1,2,3], q = [1,2,3]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)

```
输入：p = [1,2], q = [1,null,2]
输出：false
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)

```
输入：p = [1,2,1], q = [1,1,2]
输出：false
```

 

**提示：**

- 两棵树上的节点数目都在范围 `[0, 100]` 内
- `-104 <= Node.val <= 104`

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
// 思路：递归判断左边和右边就好，最后判断左右都是否相同
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null) {
            return true;
        }
        if(p != null && q != null) {
            if(p.val == q.val) {
                boolean l = isSameTree(p.left, q.left);
                boolean r = isSameTree(p.right, q.right);
                return l && r;
            } 
        }
        return false;
    }
}
```

## [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```

 

**提示：**

- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        // 后序遍历
        if(root == null) return root;
        TreeNode l = invertTree(root.left);
        TreeNode r = invertTree(root.right);
        root.left = r;
        root.right = l;
        return root;
    }
}
```

## [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 

**示例 1：**

![img](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

 

**提示：**

- 树中节点数目在范围 `[1, 1000]` 内
- `-100 <= Node.val <= 100`

 

**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
 // 递归法
class Solution {
    public boolean solve(TreeNode l, TreeNode r) {
        if(l == null && r == null) {
            return true;
        }
        if(l != null && r != null) {
            if(l.val == r.val) {
                // 这里是反的，需要注意处理
                return solve(l.left, r.right) && solve(l.right, r.left);
            }
        }
        // 其他情况都返回false
        return false;
    }
    public boolean isSymmetric(TreeNode root) {
        if(root == null) {
            return true;
        }
        // 分成两颗树
        return solve(root.left, root.right);
    }
}
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
 // 迭代法

// 自己想到的是用bfs遍历
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root, root);
    }

    public boolean check(TreeNode u, TreeNode v) {
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        q.offer(u);
        q.offer(v);
        while (!q.isEmpty()) {
            u = q.poll();
            v = q.poll();
            if (u == null && v == null) {
                continue;
            }
            if ((u == null || v == null) || (u.val != v.val)) {
                return false;
            }

            q.offer(u.left);
            q.offer(v.right);

            q.offer(u.right);
            q.offer(v.left);
        }
        return true;
    }
}
```

## [112. 路径总和](https://leetcode.cn/problems/path-sum/)

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

**示例 3：**

```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```

 

**提示：**

- 树中节点的数目在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

 // 需要注意的是叶子节点是没有子节点的节点，而不是判断一个节点是null，就返回
class Solution {
    public boolean solve(TreeNode root, int nowSum, int targetSum) {
        // 在这个判读中不可能到达这一步的
        // if(root == null) {
        //     return false;
        // }
        TreeNode l = root.left;
        TreeNode r = root.right;
        if(l == null && r == null) {
            if(nowSum == targetSum) return true;
            return false;
        }
        // 一定要判断是否为空
        boolean leftRes = l != null && solve(l, nowSum + l.val, targetSum);
        if(leftRes) return leftRes;
        return r != null && solve(r, nowSum + r.val, targetSum);
    }
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        return solve(root, root.val, targetSum);
    }
}
```

```java
// 官方题解

class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return sum == root.val;
        }
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}
```

## ==[114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)==

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [0]
输出：[0]
```

 

**提示：**

- 树中结点数在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

 

**进阶：**你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？

[114. 二叉树展开为链表 - 力扣（LeetCode）](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solutions/17274/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/?envType=study-plan-v2&envId=top-interview-150)

解法一
可以发现展开的顺序其实就是二叉树的先序遍历。算法和 94 题中序遍历的 Morris 算法有些神似，我们需要两步完成这道题。

将左子树插入到右子树的地方
将原来的右子树接到左子树的最右边节点
考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null
可以看图理解下这个过程。

Java
    1
   / \
  2   5
 / \   \
3   4   6

//将 1 的左子树插入到右子树的地方
    1
     \
      2         5
     / \         \
    3   4         6        
//将原来的右子树接到左子树的最右边节点
    1
     \
      2          
     / \          
    3   4  
         \
          5
           \
            6
            
 //将 2 的左子树插入到右子树的地方
    1
     \
      2          
       \          
        3       4  
                 \
                  5
                   \
                    6   
        
 //将原来的右子树接到左子树的最右边节点
    1
     \
      2          
       \          
        3      
         \
          4  
           \
            5
             \
              6         

  ......

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
   public void flatten(TreeNode root) {
    while (root != null) { 
        //左子树为 null，直接考虑下一个节点
        if (root.left == null) {
            root = root.right;
        } else {
            // 找左子树最右边的节点
            TreeNode pre = root.left;
            while (pre.right != null) {
                pre = pre.right;
            } 
            //将原来的右子树接到左子树的最右边节点
            pre.right = root.right;
            // 将左子树插入到右子树的地方
            root.right = root.left;
            root.left = null;
            // 考虑下一个节点
            root = root.right;
        }
    }
}
}
```

## ==[222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)==

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2h` 个节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)

```
输入：root = [1,2,3,4,5,6]
输出：6
```

**示例 2：**

```
输入：root = []
输出：0
```

**示例 3：**

```
输入：root = [1]
输出：1
```

 

**提示：**

- 树中节点的数目范围是`[0, 5 * 104]`
- `0 <= Node.val <= 5 * 104`
- 题目数据保证输入的树是 **完全二叉树**

 

**进阶：**遍历树来统计节点是一种时间复杂度为 `O(n)` 的简单解决方案。你可以设计一个更快的算法吗？



==很难==

==官方题解是的是二进制==

```java
```

==dfs优化，O(logn^2)==

![image-20240829231049066](https://aliyun-imgbed.oss-cn-beijing.aliyuncs.com/img/image-20240829231049066.png)

简单理解为每次循环logn，一共有logn次循环就行了,求高度是logn, 需要求logn次（这么高的节点）

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null){
           return 0;
        } 
        int left = countLevel(root.left);
        int right = countLevel(root.right);
        if(left == right){
            return countNodes(root.right) + (1<<left);
        }else{
            return countNodes(root.left) + (1<<right);
        }
    }
    //求高度，利用完全二叉树的特点，左右必须是满的，在最后一层之前，所以可以一直遍历左节点
    private int countLevel(TreeNode root){
        int level = 0;
        while(root != null){
            level++;
            root = root.left;
        }
        return level;
    }
}

```

## ==[129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)==

给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。

每条从根节点到叶节点的路径都代表一个数字：

- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。

计算从根节点到叶节点生成的 **所有数字之和** 。

**叶节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg)

```
输入：root = [1,2,3]
输出：25
解释：
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg)

```
输入：root = [4,9,0,5,1]
输出：1026
解释：
从根到叶子节点路径 4->9->5 代表数字 495
从根到叶子节点路径 4->9->1 代表数字 491
从根到叶子节点路径 4->0 代表数字 40
因此，数字总和 = 495 + 491 + 40 = 1026
```

 

**提示：**

- 树中节点的数目在范围 `[1, 1000]` 内
- `0 <= Node.val <= 9`
- 树的深度不超过 `10`

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int solve(TreeNode root, int sum){
        if(root == null ) {
            //这里需要特别注意，并不构成一条链， 1 ，2这种情况，1的右边是没有的
            return 0;
        }
        // 判断一下，不然会重复返回两次相同的sum，只有这种情况（叶子节点）才会返回值，其他情况都是返回0
        if(root.left == null && root.right == null) {
            return sum * 10 + root.val;
        }
        return solve(root.left, sum * 10 + root.val) + solve(root.right, sum * 10 + root.val);
    }
    public int sumNumbers(TreeNode root) {
        if(root == null) return 0;
        return solve(root,0);
    }
}
```

##== [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)==

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

 

**提示：**

- 树中节点数目在范围 `[2, 105]` 内。
- `-109 <= Node.val <= 109`
- 所有 `Node.val` `互不相同` 。
- `p != q`
- ==`p` 和 `q` 均存在于给定的二叉树中。==

![image-20240901224954870](https://aliyun-imgbed.oss-cn-beijing.aliyuncs.com/img/image-20240901224954870.png)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q) {
            return root;
        }
        //向左向右dfs
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        // 其实题中说了不会出现这种情况的
        if(left == null && right == null) return null;
        // 左右没有p和q
        if(left == null) return right;
        // 右边没有p和q
        if(right == null) return left;
        // 左右两都有p和q，那么就是当前root
        return root;

        
    }
}
```

## [173. 二叉搜索树迭代器](https://leetcode.cn/problems/binary-search-tree-iterator/)

实现一个二叉搜索树迭代器类`BSTIterator` ，表示一个按中序遍历二叉搜索树（BST）的迭代器：

- `BSTIterator(TreeNode root)` 初始化 `BSTIterator` 类的一个对象。BST 的根节点 `root` 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。
- `boolean hasNext()` 如果向指针右侧遍历存在数字，则返回 `true` ；否则返回 `false` 。
- `int next()`将指针向右移动，然后返回指针处的数字。

注意，指针初始化为一个不存在于 BST 中的数字，所以对 `next()` 的首次调用将返回 BST 中的最小元素。

你可以假设 `next()` 调用总是有效的，也就是说，当调用 `next()` 时，BST 的中序遍历中至少存在一个下一个数字。

 

**示例：**

![img](https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png)

```
输入
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
输出
[null, 3, 7, true, 9, true, 15, true, 20, false]

解释
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // 返回 3
bSTIterator.next();    // 返回 7
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 9
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 15
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 20
bSTIterator.hasNext(); // 返回 False
```

 

**提示：**

- 树中节点的数目在范围 `[1, 105]` 内
- `0 <= Node.val <= 106`
- 最多调用 `105` 次 `hasNext` 和 `next` 操作

 

**进阶：**

- 你可以设计一个满足下述条件的解决方案吗？`next()` 和 `hasNext()` 操作均摊时间复杂度为 `O(1)` ，并使用 `O(h)` 内存。其中 `h` 是树的高度。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
 // 中序遍历的迭代器
 // 简单思路，使用arr存储一下就行, 栈
class BSTIterator {
    private List<Integer> list = new ArrayList<>();
    private void dfs(TreeNode root) {
        if(root == null) return;
        dfs(root.left);
        list.add(root.val);
        dfs(root.right);
    }
    public BSTIterator(TreeNode root) {
        dfs(root);
    }
    
    public int next() {
        return list.remove(0);
    }
    
    public boolean hasNext() {
        return list.size() != 0;
    }
}

/**
 * Your BSTIterator object will be instantiated and called as such:
 * BSTIterator obj = new BSTIterator(root);
 * int param_1 = obj.next();
 * boolean param_2 = obj.hasNext();
 */
```

```java
//使用stack的方式，模拟递归的过程
class BSTIterator {
    private TreeNode cur;
    private Deque<TreeNode> stack;

    public BSTIterator(TreeNode root) {
        cur = root;
        stack = new LinkedList<TreeNode>();
    }
    
    public int next() {
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        cur = stack.pop();
        int ret = cur.val;
        cur = cur.right;
        return ret;
    }
    
    public boolean hasNext() {
        // 还有可以遍历下去的节点，或者stack不为空，没有遍历完
        return cur != null || !stack.isEmpty();
    }
}

```

## [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
```

**示例 2:**

```
输入：inorder = [-1], postorder = [-1]
输出：[-1]
```

 

**提示:**

- `1 <= inorder.length <= 3000`
- `postorder.length == inorder.length`
- `-3000 <= inorder[i], postorder[i] <= 3000`
- `inorder` 和 `postorder` 都由 **不同** 的值组成
- `postorder` 中每一个值都在 `inorder` 中
- `inorder` **保证**是树的中序遍历
- `postorder` **保证**是树的后序遍历

![image-20240902153236327](https://aliyun-imgbed.oss-cn-beijing.aliyuncs.com/img/image-20240902153236327.png)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
 // 我们需要知道中序遍历中的中心节点的下标来区分左右子树，所有可以先记录
class Solution {

    private Map<Integer, Integer> idx_map = new HashMap();
    // 区间，左闭右开
    // 这个函数就是知道当前的中序和后序遍历，然后构建一颗子树，然后不断的递归
    private TreeNode dfs(int[] inorder, int[] postorder, int inorder_left, int inorder_right,int postorder_left, int postorder_right) {
        // 空节点，因为是左闭，右开，所有当他们相等时，代表已经遍历完成
        if(postorder_left == postorder_right) return null;
        int n = postorder_right - 1;
        int index_root = idx_map.get(postorder[n]);
        int leftSize = index_root - inorder_left;
        // 需要注意的就是左闭右开
        TreeNode left = dfs(inorder, postorder,inorder_left, index_root,postorder_left, postorder_left + leftSize);
        TreeNode right = dfs(inorder, postorder,index_root + 1, inorder_right,postorder_left + leftSize, n);
        return new TreeNode(postorder[n],left,right);
    }

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        for(int i = 0; i < inorder.length; i++) {
            idx_map.put(inorder[i],i);
        }
        return dfs(inorder, postorder, 0, inorder.length, 0, postorder.length);
    }
}
```

## [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

已解答

中等



相关标签

相关企业



给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

**示例 2:**

```
输入: preorder = [-1], inorder = [-1]
输出: [-1]
```

 

**提示:**

- `1 <= preorder.length <= 3000`
- `inorder.length == preorder.length`
- `-3000 <= preorder[i], inorder[i] <= 3000`
- `preorder` 和 `inorder` 均 **无重复** 元素
- `inorder` 均出现在 `preorder`
- `preorder` **保证** 为二叉树的前序遍历序列
- `inorder` **保证** 为二叉树的中序遍历序列

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private Map<Integer, Integer> idx = new HashMap<>();
    // 左闭，右闭合
    private TreeNode f(int[] preorder, int[] inorder, int pL, int pR, int iL, int iR){
        // 递归结束
        if(iL > iR) {
            return null;
        }
        int rootIdx = idx.get(preorder[pL]);
        int leftTreeSize = rootIdx - iL;
        TreeNode left = f(preorder, inorder, pL + 1, pL + leftTreeSize, rootIdx - leftTreeSize, rootIdx - 1);
        TreeNode right = f(preorder, inorder, pL + leftTreeSize + 1, pR, rootIdx + 1, iR);
        return new TreeNode(preorder[pL], left, right);
    }
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        // 因为inorder可以区分左右子树，所以需要得到它的idx，方便快速查找
        for(int i = 0; i < inorder.length; i++) {
            idx.put(inorder[i],i);
        }
        return f(preorder, inorder, 0, preorder.length - 1, 0, inorder.length - 1);
    }
}
```

## [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

中等



相关标签

相关企业



给定一个二叉树：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL` 。

初始状态下，所有 next 指针都被设置为 `NULL` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2019/02/15/117_sample.png)

```
输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。
```

**示例 2：**

```
输入：root = []
输出：[]
```

 

**提示：**

- 树中的节点数在范围 `[0, 6000]` 内
- `-100 <= Node.val <= 100`

**进阶：**

- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。

1. 使用BFS+队列

```java
class Solution {
    public Node connect(Node root) {
        if (root == null) {
            return null;
        }
        List<Node> q = List.of(root);
        while (!q.isEmpty()) {
            List<Node> tmp = q;
            q = new ArrayList<>();
            for (int i = 0; i < tmp.size(); i++) {
                Node node = tmp.get(i);
                if (i > 0) { // 连接同一层的两个相邻节点
                    tmp.get(i - 1).next = node;
                }
                if (node.left != null) {
                    q.add(node.left);
                }
                if (node.right != null) {
                    q.add(node.right);
                }
            }
        }
        return root;
    }
}
```

2. BFS+链表, 可以做到常量级的空间复杂度

把每一层看过一个链表，遍历这个链表时，连接下层的left和right为新的链表，当前层遍历完时，转移到下一层

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        Node dummy = new Node();
        // 当前层的头节点
        Node cur = root;
        while(cur != null) {
            // 到达当前层，需要清空虚拟节点的状态
            dummy.next = null;
            // 防止dummy被破坏，因为后续要需要用它
            Node nxt = dummy;// 下一层的链表
            // 如果当前层不为空
            while(cur != null) {
                Node left = cur.left;
                if(left != null) {
                    nxt.next = left;
                    nxt = nxt.next;
                }
                Node right = cur.right;
                if(right != null) {
                    nxt.next = right;
                    nxt = nxt.next;
                }
                cur = cur.next;
            }
            // 转移到下一层，这也是为什么要保留dummy的原因
            cur = dummy.next;
        }
        return root;
    }
}
```

## ==[124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)==



困难





二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

 

**提示：**

- 树中节点数目范围是 `[1, 3 * 104]`
- `-1000 <= Node.val <= 1000`

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private int ans = Integer.MIN_VALUE;
    private int f(TreeNode root) {
        if(root == null) {
            return 0;
        }
        // 如果如果是负数，则为0,也就是相当于舍去某一条分支
        int leftMax = Math.max(f(root.left), 0);
        int rightMax = Math.max(f(root.right), 0);
        // 以当前root为连接点，跟新ans
        ans = Math.max(ans, leftMax + rightMax + root.val);

        // 返回给上级，需要的哪一条分支
        return Math.max(leftMax, rightMax) + root.val;
    }
    public int maxPathSum(TreeNode root) {
        f(root);
        return ans;
    }
}
```

## [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

中等

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)

```
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
```

**示例 2:**

```
输入: [1,null,3]
输出: [1,3]
```

**示例 3:**

```
输入: []
输出: []
```

 

**提示:**

- 二叉树的节点个数的范围是 `[0,100]`
- `-100 <= Node.val <= 100` 

==考察层次遍历==

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
 // 每一层的最右边就是的
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        List<Integer> ans = new ArrayList<>();
        if(root == null ) {
            return ans;
        }
        queue.offer(root);
        // 当前层的个数，用于检测是否是当前层的最后一个节点
        int curSize = queue.size();
        while(queue.size() != 0) {
            TreeNode nowNode = queue.poll();
            if(nowNode.left != null) {
                queue.offer(nowNode.left);
            }
            if(nowNode.right != null) {
                queue.offer(nowNode.right);
            }
            // 当前层是否遍历完成
            if(--curSize == 0) {
                ans.add(nowNode.val);
                // 重置大小
                curSize = queue.size();
            }
        }
        return ans;
    }
}
```

dfs

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        dfs(root, 0, ans);
        return ans;
    }

    private void dfs(TreeNode root, int depth, List<Integer> ans) {
        if (root == null) {
            return;
        }
        if (depth == ans.size()) { // 这个深度首次遇到
            ans.add(root.val);
        }
        dfs(root.right, depth + 1, ans); // 先递归右子树，保证首次遇到的一定是最右边的节点
        dfs(root.left, depth + 1, ans);
    }
}
```

## [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

简单

给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 `10^5` 以内的答案可以被接受。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[3.00000,14.50000,11.00000]
解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。
因此返回 [3, 14.5, 11] 。
```

**示例 2:**

![img](https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg)

```
输入：root = [3,9,20,15,7]
输出：[3.00000,14.50000,11.00000]
```

 

**提示：**



- 树中节点数量在 `[1, 104]` 范围内
- `-231 <= Node.val <= 231 - 1`

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        List<Double> ans = new ArrayList<>();
        queue.offer(root);
        // 当前层的个数，用于检测是否是当前层的最后一个节点
        int curSize = queue.size();
        int t = curSize;
        double sum = 0.0; 
        while(queue.size() != 0) {
            TreeNode nowNode = queue.poll();
            sum += nowNode.val;
            if(nowNode.left != null) {
                queue.offer(nowNode.left);
            }
            if(nowNode.right != null) {
                queue.offer(nowNode.right);
            }
            // 当前层是否遍历完成
            if(--curSize == 0) {
                ans.add(sum / t);
                // 重置大小
                curSize = queue.size();
                t = curSize;
                sum = 0.0;
            }
        }
        return ans;
    }
}
```

## [103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

中等

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

 

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

==BFS + 双端队列(答案队列)==

只需要判断怎么加入列表就行了，BFS还是正常的从左到右，只是加入答案List的时候是从左到右，还是从右到左。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
 // BFS + 双端队列(答案队列)
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans = new LinkedList<List<Integer>>();
        if (root == null) {
            return ans;
        }
        Queue<TreeNode> nodeQueue = new LinkedList<TreeNode>();
        nodeQueue.add(root);
        while(!nodeQueue.isEmpty()) {
            int size = nodeQueue.size();
            LinkedList<Integer> tmp = new LinkedList<>();
            for(int i = 0; i < size; i++) {
                // 取队首
                TreeNode node = nodeQueue.poll();
                // 长度是偶数，则下一层是右到左
                if(ans.size() % 2 == 0) {
                    tmp.addLast(node.val);
                } else {
                    tmp.addFirst(node.val);
                }
                if (node.left != null) nodeQueue.add(node.left);
                if (node.right != null) nodeQueue.add(node.right);
            }
            ans.add(tmp);
        }
        return ans;
    }
}
```

## 二叉搜索树

# 图

## [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

已解答

中等



相关标签

相关企业



给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`

==dfs或者bfs即可==

```java
class Solution {
    // 四个方向
    int[] dx = {0,0,1,-1};
    int[] dy = {1,-1,0,0};
    int ans = 0;
    // 岛屿变成0
    void f(char[][] grid,int x,int y) {
        if(grid[x][y] == '0') {
            return;
        }
        grid[x][y] = '0';
        for(int i = 0; i < 4; i++) {
            // 一定要注意图的边界条件
            if((x + dx[i]) >= 0 && (x + dx[i]) < grid.length && (y + dy[i]) >= 0 && (y + dy[i]) < grid[0].length) {
                f(grid, x + dx[i], y + dy[i]);
            }
        }
    }
    public int numIslands(char[][] grid) {
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] != '0') {
                    f(grid,i,j);
                    ans++;
                }
            }
        }
        return ans;
    }
}
```

给你一个 `m x n` 的矩阵 `board` ，由若干字符 `'X'` 和 `'O'` 组成，**捕获** 所有 **被围绕的区域**：

- **连接：**一个单元格与水平或垂直方向上相邻的单元格连接。
- **区域：连接所有** `'O'` 的单元格来形成一个区域。
- **围绕：**如果您可以用 `'X'` 单元格 **连接这个区域**，并且区域中没有任何单元格位于 `board` 边缘，则该区域被 `'X'` 单元格围绕。

通过将输入矩阵 `board` 中的所有 `'O'` 替换为 `'X'` 来 **捕获被围绕的区域**。

 

**示例 1：**

**输入：**board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]

**输出：**[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]

**解释：**

![img](https://pic.leetcode.cn/1718167191-XNjUTG-image.png)

在上图中，底部的区域没有被捕获，因为它在 board 的边缘并且不能被围绕。

**示例 2：**

**输入：**board = [["X"]]

**输出：**[["X"]]

 

**提示：**

- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 200`
- `board[i][j]` 为 `'X'` 或 `'O'`

```java
/**
第一次做，被困住了，其实我们只需要逆向思维就好

题中提到了且区域中没有任何单元格位于 board 边缘，则该区域被 'X' 单元格围绕。

我们可以逆向思维：遍历边缘的O，然后标记和它相连的区域标记，最后遍历为标记的O变成X就好

 */
class Solution {
    int m, n;
    void dfs(char[][] board, int x, int y) {

        if (x < 0 || x >= m || y < 0 || y >= n || board[x][y] != 'O') {
            return;
        }
        board[x][y] = 'A';
        dfs(board, x + 1, y);
        dfs(board, x - 1, y);
        dfs(board, x, y + 1);
        dfs(board, x, y - 1);
    }
    public void solve(char[][] board) {
        m = board.length;
        n = board[0].length;
        // 上下边缘
        for(int i = 0; i < n; i++) {
            dfs(board,0,i);
            dfs(board,m - 1,i);
        }
        // 左右边缘
        for(int i = 1; i < m - 1; i++) {
            dfs(board,i,0);
            dfs(board,i,n - 1);
        }
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(board[i][j] == 'A') {
                    board[i][j] = 'O';
                } else if(board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
            }
        }
    }
}
```

## [133. 克隆图](https://leetcode.cn/problems/clone-graph/)

给你无向 **[连通](https://baike.baidu.com/item/连通图/6460995?fr=aladdin)** 图中一个节点的引用，请你返回该图的 [**深拷贝**](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)（克隆）。

图中的每个节点都包含它的值 `val`（`int`） 和其邻居的列表（`list[Node]`）。

```
class Node {
    public int val;
    public List<Node> neighbors;
}
```

 

**测试用例格式：**

简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（`val = 1`），第二个节点值为 2（`val = 2`），以此类推。该图在测试用例中使用邻接列表表示。

**邻接列表** 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。

给定节点将始终是图中的第一个节点（值为 1）。你必须将 **给定节点的拷贝** 作为对克隆图的引用返回。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png)

```
输入：adjList = [[2,4],[1,3],[2,4],[1,3]]
输出：[[2,4],[1,3],[2,4],[1,3]]
解释：
图中有 4 个节点。
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png)

```
输入：adjList = [[]]
输出：[[]]
解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。
```

**示例 3：**

```
输入：adjList = []
输出：[]
解释：这个图是空的，它不含任何节点。
```

 

**提示：**

- 这张图中的节点数在 `[0, 100]` 之间。
- `1 <= Node.val <= 100`
- 每个节点值 `Node.val` 都是唯一的，
- 图中没有重复的边，也没有自环。
- 图是连通图，你可以从给定节点访问到所有节点。

```java
// 自己写的方法
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/

class Solution {
    Map<Integer, Node> m = new HashMap();
    public Node cloneGraph(Node node) {
        if(node == null) return null;
        if(m.containsKey(node.val)) {
            return m.get(node.val);
        }
        ArrayList<Node> neighbors = new ArrayList<Node>();
        Node newNode = new Node(node.val);
        m.put(node.val, newNode);
        for(Node neighborNode: node.neighbors) {
            neighbors.add(cloneGraph(neighborNode));
        }
        newNode.neighbors = neighbors;
        return newNode;
    }
}
```

[399. 除法求值](https://leetcode.cn/problems/evaluate-division/)


代码



测试用例

测试用例



测试结果

[399. 除法求值](https://leetcode.cn/problems/evaluate-division/)

中等



相关标签

相关企业



提示



给你一个变量对数组 `equations` 和一个实数值数组 `values` 作为已知条件，其中 `equations[i] = [Ai, Bi]` 和 `values[i]` 共同表示等式 `Ai / Bi = values[i]` 。每个 `Ai` 或 `Bi` 是一个表示单个变量的字符串。

另有一些以数组 `queries` 表示的问题，其中 `queries[j] = [Cj, Dj]` 表示第 `j` 个问题，请你根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。

返回 **所有问题的答案** 。如果存在某个无法确定的答案，则用 `-1.0` 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 `-1.0` 替代这个答案。

**注意：**输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

**注意：**未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。

 

**示例 1：**

```
输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
解释：
条件：a / b = 2.0, b / c = 3.0
问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
注意：x 是未定义的 => -1.0
```

**示例 2：**

```
输入：equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]
输出：[3.75000,0.40000,5.00000,0.20000]
```

**示例 3：**

```
输入：equations = [["a","b"]], values = [0.5], queries = [["a","b"],["b","a"],["a","c"],["x","y"]]
输出：[0.50000,2.00000,-1.00000,-1.00000]
```

 

**提示：**

- `1 <= equations.length <= 20`
- `equations[i].length == 2`
- `1 <= Ai.length, Bi.length <= 5`
- `values.length == equations.length`
- `0.0 < values[i] <= 20.0`
- `1 <= queries.length <= 20`
- `queries[i].length == 2`
- `1 <= Cj.length, Dj.length <= 5`
- `Ai, Bi, Cj, Dj` 由小写英文字母与数字组成

==自己没有思路==

====

```java
```

## [207. 课程表](https://leetcode.cn/problems/course-schedule/)

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```

**示例 2：**

```
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
```

 

**提示：**

- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `prerequisites[i]` 中的所有课程对 **互不相同**

```java
/**
具体的算法：
https://blog.csdn.net/weixin_42001089/article/details/84327306#:~:text=%E5%AF%B9%E4%B8%80%E4%B8%AA%20%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF
 */
class Solution {
    // prerequisites[i] = [ai, bi] =》 bi -> ai 必须先学习bi
    // 这个时候就要使用拓扑排序了， 拓扑排序是针对有向无环图的
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 入度
        int[] inDegrees = new int[numCourses];
        // 邻接表
        List<List<Integer>> edges = new ArrayList<>();
        // 初始化邻接表
        for(int i = 0; i < numCourses; i++) {
            edges.add(new ArrayList<Integer>());
        }
        // 初始化邻接表 和 入度 
        for(int [] prerequisite: prerequisites) {
            inDegrees[prerequisite[0]]++;
            edges.get(prerequisite[1]).add(prerequisite[0]);
        }
        // 度为0节点访问数
        int count = 0;
        // 使用bfs
        Queue<Integer> q = new LinkedList();
        for(int i = 0; i< numCourses; i++) {
            if(inDegrees[i] == 0) {
                q.offer(i);
            }
        }
        while(!q.isEmpty()) {
            int u = q.poll();
            count++;
            // 遍历邻接
            for(int v : edges.get(u)) {
                // 如果入度为0
                if(--inDegrees[v] == 0) {
                    q.offer(v);
                }
            }
        }
        return count == numCourses;
    }
}
```

## [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

现在你总共有 `numCourses` 门课需要选，记为 `0` 到 `numCourses - 1`。给你一个数组 `prerequisites` ，其中 `prerequisites[i] = [ai, bi]` ，表示在选修课程 `ai` 前 **必须** 先选修 `bi` 。

- 例如，想要学习课程 `0` ，你需要先完成课程 `1` ，我们用一个匹配来表示：`[0,1]` 。

返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 **任意一种** 就可以了。如果不可能完成所有课程，返回 **一个空数组** 。

 

**示例 1：**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：[0,1]
解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
```

**示例 2：**

```
输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
输出：[0,2,1,3]
解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
```

**示例 3：**

```
输入：numCourses = 1, prerequisites = []
输出：[0]
```

 

**提示：**

- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= numCourses * (numCourses - 1)`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `ai != bi`
- 所有`[ai, bi]` **互不相同**

==记录遍历的过程即可==

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // 入度
        int[] inDegrees = new int[numCourses];
        int[] ans = new int[numCourses];
        // 邻接表
        List<List<Integer>> edges = new ArrayList<>();
        // 初始化邻接表
        for(int i = 0; i < numCourses; i++) {
            edges.add(new ArrayList<Integer>());
        }
        // 初始化邻接表 和 入度 
        for(int [] prerequisite: prerequisites) {
            inDegrees[prerequisite[0]]++;
            edges.get(prerequisite[1]).add(prerequisite[0]);
        }
        // 度为0节点访问数
        int count = 0;
        // 使用bfs
        Queue<Integer> q = new LinkedList();
        for(int i = 0; i< numCourses; i++) {
            if(inDegrees[i] == 0) {
                q.offer(i);
            }
        }
        while(!q.isEmpty()) {
            int u = q.poll();
            ans[count++] = u;
            // 遍历邻接
            for(int v : edges.get(u)) {
                // 如果入度为0
                if(--inDegrees[v] == 0) {
                    q.offer(v);
                }
            }
        }
        return count == numCourses ? ans : new int[0];
    }
}
```

## [433. 最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/)

基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 `'A'`、`'C'`、`'G'` 和 `'T'` 之一。

假设我们需要调查从基因序列 `start` 变为 `end` 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。

- 例如，`"AACCGGTT" --> "AACCGGTA"` 就是一次基因变化。

另有一个基因库 `bank` 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 `bank` 中）

给你两个基因序列 `start` 和 `end` ，以及一个基因库 `bank` ，请你找出并返回能够使 `start` 变化为 `end` 所需的最少变化次数。如果无法完成此基因变化，返回 `-1` 。

注意：起始基因序列 `start` 默认是有效的，但是它并不一定会出现在基因库中。

 

**示例 1：**

```
输入：start = "AACCGGTT", end = "AACCGGTA", bank = ["AACCGGTA"]
输出：1
```

**示例 2：**

```
输入：start = "AACCGGTT", end = "AAACGGTA", bank = ["AACCGGTA","AACCGCTA","AAACGGTA"]
输出：2
```

**示例 3：**

```
输入：start = "AAAAACCC", end = "AACCCCCC", bank = ["AAAACCCC","AAACCCCC","AACCCCCC"]
输出：3
```

 

**提示：**

- `start.length == 8`
- `end.length == 8`
- `0 <= bank.length <= 10`
- `bank[i].length == 8`
- `start`、`end` 和 `bank[i]` 仅由字符 `['A', 'C', 'G', 'T']` 组成

```java

// 需要找的是最小的变化次数，最简单的办法就是暴力解决BFS, BFS一旦找到就是最小的的
// 忘记使用StringBuffer了，真该死啊， Stringbuffer才能方便的改变字符串的某一个字符


class Solution {

    public int minMutation(String startGene, String endGene, String[] bank) {
        // 记录是否在bank中
        Set<String> cnt = new HashSet<>();
        // 有可能后续的变换前面已经出现过了，所有要判断是否已经出现了
        Set<String> visited = new HashSet<>();
        char[] keys = {'A', 'C', 'G', 'T'};
        for(String w : bank) {
            cnt.add(w);
        }
        // 如果初始就在bank中
        if(startGene.equals(endGene)) {
            return 0;
        }
        // 如果连end都不在bank中，那么就无法变化
        if (!cnt.contains(endGene)) {
            return -1;
        }
        int step = 1;
        //使用bfs
        Queue<String> q = new LinkedList<>();
        q.offer(startGene);
        visited.add(startGene);
        while(!q.isEmpty()) {
            // 获得当前bfs层的size
            int size = q.size();
            // 遍历当前层
            for(int i = 0; i < size; i++) {
                String s = q.poll();
                for(int j = 0; j < 8; j++) {
                    for(int k = 0; k < 4; k++) {
                        if(keys[k] != s.charAt(j)) {
                            StringBuffer sb = new StringBuffer(s);
                            sb.setCharAt(j, keys[k]);
                            String next = sb.toString();
                            //next没有出现过并且在bank中
                            if(!visited.contains(next) && cnt.contains(next)) {
                                // 和endGene 匹配
                                if(next.equals(endGene)) {
                                    return step;
                                }
                                q.offer(next);
                                visited.add(next);
                            }
                        }
                    }
                }
            }
            // 这一层结束
            step++;
        }

        return -1;
    }
}
```

## [127. 单词接龙](https://leetcode.cn/problems/word-ladder/)

字典 `wordList` 中从单词 `beginWord` 到 `endWord` 的 **转换序列** 是一个按下述规格形成的序列 `beginWord -> s1 -> s2 -> ... -> sk`：

- 每一对相邻的单词只差一个字母。
-  对于 `1 <= i <= k` 时，每个 `si` 都在 `wordList` 中。注意， `beginWord` 不需要在 `wordList` 中。
- `sk == endWord`

给你两个单词 `beginWord` 和 `endWord` 和一个字典 `wordList` ，返回 *从 `beginWord` 到 `endWord` 的 **最短转换序列** 中的 **单词数目*** 。如果不存在这样的转换序列，返回 `0` 。

 

**示例 1：**

```
输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
输出：5
解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。
```

**示例 2：**

```
输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
输出：0
解释：endWord "cog" 不在字典中，所以无法进行转换。
```

 

**提示：**

- `1 <= beginWord.length <= 10`
- `endWord.length == beginWord.length`
- `1 <= wordList.length <= 5000`
- `wordList[i].length == beginWord.length`
- `beginWord`、`endWord` 和 `wordList[i]` 由小写英文字母组成
- `beginWord != endWord`
- `wordList` 中的所有字符串 **互不相同**

```java
class Solution {
    // 这道题是和之前的最小基因变化是一道题的样子
    // 使用bfs遍历，找的到就是最短的路径
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        // 是否在wordList中
        Set<String> cnt = new HashSet<>(wordList);
        // 是否已经是前面已经出现过，反正重复
        Set<String> visited = new HashSet<>();
        // endword都不在wordList中
        if(!cnt.contains(endWord)) {
            return 0;
        }
        // 队列，用于bfs
        Queue<String> q = new ArrayDeque<>();
        q.offer(beginWord);
        visited.add(beginWord);
        int step = 0;
        while(!q.isEmpty()) {
            int size = q.size();
            // 当前这一层的bfs就是一步
            step++;
            for(int i = 0; i < size; i++) {
                String s = q.poll();
                for(int j = 0; j < s.length(); j++) {
                    // 遍历26字母
                    for(int k = 0; k < 26; k++) {
                        StringBuffer sb = new StringBuffer(s);
                        sb.setCharAt(j, (char)('a' + k));
                        String nextString = sb.toString();
                        if(cnt.contains(nextString) && !visited.contains(nextString)) {
                            if(endWord.equals(nextString)) {
                                return step + 1;
                            } 
                            visited.add(nextString);
                            q.offer(nextString);
                        }
                    }
                }
            }
        }
        return 0;
    }
}
```

# 回溯

## [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)

 

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**示例 2：**

```
输入：digits = ""
输出：[]
```

**示例 3：**

```
输入：digits = "2"
输出：["a","b","c"]
```

 

**提示：**

- `0 <= digits.length <= 4`
- `digits[i]` 是范围 `['2', '9']` 的一个数字。

```java
// 直接dfs即可
class Solution {
    List<String> ans = new ArrayList<String>();
    private char[] path;
    Map<Character, String> phoneMap = new HashMap<Character, String>() {{
        put('2', "abc");
        put('3', "def");
        put('4', "ghi");
        put('5', "jkl");
        put('6', "mno");
        put('7', "pqrs");
        put('8', "tuv");
        put('9', "wxyz");
    }};
    private void f(char [] d, int i) {
        if(i == d.length) {
            ans.add(String.valueOf(path));
            return;
        }
        for(char c : phoneMap.get(d[i]).toCharArray()) {
            path[i] = c;
            f(d, i + 1);
        }
    }
    public List<String> letterCombinations(String digits) {
        if (digits.length() == 0) {
            return ans;
        }
        this.path = new char[digits.length()];
        
        f(digits.toCharArray(), 0);
        return ans;
    }
}
```

## [77. 组合](https://leetcode.cn/problems/combinations/)

## [79. 单词搜索](https://leetcode.cn/problems/word-search/)

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出：false
```

 

**提示：**

- `m == board.length`
- `n = board[i].length`
- `1 <= m, n <= 6`
- `1 <= word.length <= 15`

- `board` 和 `word` 仅由大小写英文字母组成

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        int h = board.length, w = board[0].length;
        boolean[][] visited = new boolean[h][w];
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                boolean flag = check(board, visited, i, j, word, 0);
                if (flag) {
                    return true;
                }
            }
        }
        return false;
    }

    public boolean check(char[][] board, boolean[][] visited, int i, int j, String s, int k) {
        if (board[i][j] != s.charAt(k)) {
            return false;
        } else if (k == s.length() - 1) {
            return true;
        }
        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        boolean result = false;
        for (int[] dir : directions) {
            int newi = i + dir[0], newj = j + dir[1];
            if (newi >= 0 && newi < board.length && newj >= 0 && newj < board[0].length) {
                if (!visited[newi][newj]) {
                    visited[i][j] = true;
                    boolean flag = check(board, visited, newi, newj, s, k + 1);
                    visited[i][j] = false;
                    if (flag) {
                        return flag;
                    }
                }
            }
        }
        return result;
    }
}
```

## [46. 全排列](https://leetcode.cn/problems/permutations/)

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```

 

**提示：**

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**

```java
class Solution {
    List<List<Integer>> ans = new LinkedList<List<Integer>>();
    private void dfs(int[] nums, int step, List<Integer> path) {
        if(step == nums.length) {
            ans.add(
                new LinkedList<Integer>(path)
            );
            return;
        }
        for(int i = step; i < nums.length; i++) {
            // 交换
            int t = nums[i];
            nums[i] = nums[step];
            nums[step] = t;
            path.add(nums[step]);
            dfs(nums, step + 1,path);
            // 还原
            t = nums[step];
            nums[step] = nums[i];
            nums[i] = t;
            path.removeLast();
        }
    }
    public List<List<Integer>> permute(int[] nums) {
        dfs(nums, 0, new LinkedList<Integer>());
        return ans;
    }
}
```

# DP

==一定要注意初始边界的设定问题，dp[i]的具体问题定义，最后是转移防方程==

## 一维DP

### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

 

**提示：**

- `1 <= n <= 45`

==其实就是斐波那契数列==

```java
class Solution {
    public int climbStairs(int n) {
        int p = 0, q = 0, r = 1;
        for(int i = 1; i <= n; i++) {
            p = q;
            q = r;
            r = p + q;
        }
        return r;
    }
}
```

### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

```java
// 不相邻，最大
// dp[i] = max(dp[i] + dp[i - 2], dp[i - 1])

class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n + 1];
        for(int i = 0; i < n; i++) {
            dp[i] = nums[i];
        }
        for(int i = 1; i < n; i++) {
            if(i == 1) {
                dp[i] = Math.max(dp[i], dp[i - 1]);
            } else {
                dp[i] = Math.max(dp[i] + dp[i - 2], dp[i - 1]);
                ans = Math.max(ans, dp[i]);
            }
            
        }
        return dp[n - 1];
    }
}
```

```java
// 不相邻，最大
// dp[i] = max(dp[i] + dp[i - 2], dp[i - 1])
// 使用滚动数组优化空间
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if(n == 1) return nums[0];
        // 记录 dp[i - 1] 和 dp[i - 2]
        int prev = nums[0];
        int cur = Math.max(nums[0], nums[1]);
        for(int i = 2; i < n; i++) {       
            int t = cur;
            cur = Math.max(prev + nums[i], cur);
            prev = t;
        }
        return cur;
    }
}

```

### [139. 单词拆分](https://leetcode.cn/problems/word-break/)

已解答

中等



相关标签

相关企业



给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

 

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

 

**提示：**

- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s` 和 `wordDict[i]` 仅由小写英文字母组成
- `wordDict` 中的所有字符串 **互不相同**

```java
// dp
/*

https://leetcode.cn/problems/word-break/?envType=study-plan-v2&envId=top-interview-150


dp[i] 表示 0 - (i - 1)的串是否合理
只需要美剧 j 在 0 到 i- 1之间的最后一个单词是否合理即可完成这道题
dp[0] 看为空串
*/

class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordDictSet = new HashSet(wordDict);
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for(int i = 1; i <= s.length(); i++) {
            for(int j = 0; j < i; j++) {
                if(dp[j] && wordDictSet.contains(s.substring(j,i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```

### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

已解答

中等



相关标签

相关企业



给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

 

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

**提示：**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 231 - 1`
- `0 <= amount <= 104`

```java
class Solution {
    // 就是整数划分
    // dp[n] = min(dp[n - x] + 1, dp[n]); 迭代循环在dp[n - x]中选一个最小的出来，然后 + 1
    // dp[11] = min(dp[10], dp[9], dp[6]) => ...
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;
        for(int i = 1; i <= amount; i++) {
            for(int j = 0; j < coins.length; j++) {
                if(i >= coins[j]) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1); 
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

已解答

中等



相关标签

相关企业



给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的

子序列

。



**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

 

**提示：**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

 

**进阶：**

- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

```java
// dp[i] 是nums[i] 结尾的子序列长度
class Solution {
    public int lengthOfLIS(int[] nums) {
        int ans  = 1;
        int n = nums.length;
        int[] dp = new int[n + 1];
        // 自己都是长度1，注意初始化
        Arrays.fill(dp, 1);

        for(int i = 1; i < n; i++) {
            for(int j = 0; j < i; j++) {
                if(nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                    ans = Math.max(ans, dp[i]);
                }
            }
        }
        return ans;
    }
}
```

方法二：贪心 + 二分查找
思路与算法

考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。

基于上面的贪心思路，我们维护一个数组 d[i] ，表示长度为 i 的最长上升子序列的末尾元素的最小值，用 len 记录目前最长上升子序列的长度，起始时 len 为 1，d[1]=nums[0]。

同时我们可以注意到 d[i] 是关于 i 单调递增的。因为如果 d[j]≥d[i] 且 j<i，我们考虑从长度为 i 的最长上升子序列的末尾删除 i−j 个元素，那么这个序列长度变为 j ，且第 j 个元素 x（末尾元素）必然小于 d[i]，也就小于 d[j]。那么我们就找到了一个长度为 j 的最长上升子序列，并且末尾元素比 d[j] 小，从而产生了矛盾。因此数组 d 的单调性得证。

我们依次遍历数组 nums 中的每个元素，并更新数组 d 和 len 的值。如果 nums[i]>d[len] 则更新 len=len+1，否则在 d[1…len]中找满足 d[i−1]<nums[j]<d[i] 的下标 i，并更新 d[i]=nums[j]。

根据 d 数组的单调性，我们可以使用二分查找寻找下标 i，优化时间复杂度。

最后整个算法流程为：

设当前已求出的最长上升子序列的长度为 len（初始时为 1），从前往后遍历数组 nums，在遍历到 nums[i] 时：

如果 nums[i]>d[len] ，则直接加入到 d 数组末尾，并更新 len=len+1；

否则，在 d 数组中二分查找，找到第一个比 nums[i] 小的数 d[k] ，并更新 d[k+1]=nums[i]。

以输入序列 [0,8,4,12,2] 为例：

第一步插入 0，d=[0]；

第二步插入 8，d=[0,8]；

第三步插入 4，d=[0,4]；

第四步插入 12，d=[0,4,12]；

第五步插入 2，d=[0,2,12]。

最终得到最大递增子序列长度为 3。

```Java
C++
Python3
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = 1, n = nums.length;
        if (n == 0) {
            return 0;
        }
        int[] d = new int[n + 1];
        d[len] = nums[0];
        for (int i = 1; i < n; ++i) {
            if (nums[i] > d[len]) {
                d[++len] = nums[i];
            } else {
                int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0
                while (l <= r) {
                    int mid = (l + r) >> 1;
                    if (d[mid] < nums[i]) {
                        pos = mid;
                        l = mid + 1;
                    } else {
                        r = mid - 1;
                    }
                }
                d[pos + 1] = nums[i];
            }
        }
        return len;
    }
}
```

复杂度分析

时间复杂度：O(nlogn)。数组 nums 的长度为 n，我们依次用数组中的元素去更新 d 数组，而更新 d 数组时需要进行 O(logn) 的二分搜索，所以总时间复杂度为 O(nlogn)。

空间复杂度：O(n)，需要额外使用长度为 n 的 d 数组。

## 二维DP

